<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL - Gráficos 3D en la Web</title>
    <style>
    body{
        background-color: thistle;
        text-align: center;
        font-family: Arial, Helvetica, sans-serif;
    }
    canvas{
        padding-left: 0;
        padding-right: 0;
        margin-left: auto;
        margin-right: auto;
        display: block;
    }
    p{
        font-size: large;
        margin: 2vw 15vw;
        text-align: justify;
        text-justify: inter-word;
    }
    code{
        text-align: center;
        margin: 0vw 15vw;
    }
    #title{
        padding-top: 20px;
        margin: 0;
    }
    #name{
        margin-bottom: 0px;
    }
    #subname{
        margin-top: 0px;
    }
    img{
        text-align: center;
    }
    #img-wgl{
        width: 25vw;
        margin: 3px 0 25px 0;
    }
    </style>
</head>
<body>
    <h1 id="title">Exploración de WebGL - Gráficos 3D en la Web</h1>
    <h2>Informe final de pasantía para el profesor Jean Pierre Charalambos</h2>
    <h2 id="name">Mauricio Meza Burbano</h2>
    <h3 id="subname">Estudiante de Ingeniería de Sistemas - Universidad Nacional de Colombia</h3>

    <p> La siguiente página presenta el informe final de mi exploración con la API WebGL (Web Graphics Library), esta tecnología fue lanzada en el 2012 y es utilizada por una gran cantidad de páginas, aplicaciones y experiencias web para dibujar gráficos 3D interactivos en el navegador sin necesidad de usar plug-ins, extensiones o programas externos. 
        Durante mi pasantía en la empresa <a href="https://newrona.net/">Newrona</a> he utilizado esta tecnología para crear páginas web con componentes 3D haciendo uso de librerías de código abierto como <a href="https://threejs.org/">Three.js</a> y <a href="https://p5js.org/">P5.js</a>, estas librerías facilitan el desarrollo con WebGL abstrayendo las partes más complejas y verbosas de la API con componentes comunes del mundo digital 3D como luces, cámaras, materiales, escenas y muchos otros más.</p>
    <p> Gracias a estas librerías, dentro de mi pasantía no he encontrado una necesidad inmediata de adentrarme directamente en código de WebGL o manejar Shaders en lenguaje GLSL. Sin embargo, para entender a fondo esta tecnología, su funcionamiento, la mejor manera de usarla y desarrollar nuevas herramientas que faciliten su uso, es necesario comprender el código que corre “por detrás” y explorar la manera como WebGL realiza el proceso de renderizado desde el nivel más bajo, pixel por pixel.
        Este acercamiento utiliza como guia principal la serie de articulos <a href="https://webglfundamentals.org/">WebGL Fundamentals</a> creado por Gregg Tavares, gran parte del código que se presenta a continuación proviene de esta guia y ha sido posteriormente modificado utilizando otros libros y referencias que se presentan al final, debido a que los artículos no tienen una versión en español espero que el contenido de esta página sea una introducción rápida a los temas que se presentan en él.
    </p>
    <section>
        <hr>
        <h2>¿Que es WebGL?</h2>
        <p> WebGL es una librería de rasterizado que a nivel más simple está diseñada para dibujar líneas, puntos y triángulos sobre un Canvas de HTML, muchas aplicaciones incluso ignoran todas las funcionalidades de renderización 3D y lo utilizan solamente para generar y manipular gráficos en 2D, es por esto que todas las abstracciones comunes de los software de manipulación y renderización 3D como Objetos, Cámaras, Materiales, Luces y muchos otros de estos conceptos deben desarrollarse prácticamente desde cero con las herramientas que WebGL provee, esto se realiza al desglosar cada uno de estos componentes de un ambiente 3D en sus conceptos matemáticos más básicos como Vectores, Matrices y Escalares. 
            Al reducir la generación de gráficos a estos conceptos y operaciones del álgebra lineal, se convierte el proceso de renderización en instrucciones fácilmente computables y paralelizables de manera que puedan ser ejecutadas de una manera óptima por parte de la GPU.</p>    
        <img id="img-wgl" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/WebGL_Logo.svg/1920px-WebGL_Logo.svg.png">
    </section>
    <section>
        <hr>
        <h2>¿Qué es un Shader?</h2>
        <p> Los Shaders son programas que se ejecutan directamente en la GPU y son escritos en un lenguaje similar a C llamado GLSL, casi siempre se definen 2 tipos de shaders: El Vertex Shader que es ejecutado por cada vértice definido en la escena 3D, este en general se usa para tomar el vértice definido como un vector de tres dimensiones [X,Y,Z] y proyectarlo dentro del espacio 2D de la pantalla [X,Y]. Así mismo tenemos El Fragment Shader el cual se ejecuta por cada pixel en la pantalla y generalmente se define como un vector de 4 dimensiones [R,G,B,A], que asigna el color con el que se debe pintar ese pixel en específico.</p>
        <p>Librerías como P5.js y Three.js emplean dentro de sus APIs métodos que simplifican los procesos de configuración de WebGL y autogeneran shaders a partir de inputs del usuario que presentan y modifican los ambientes 3D interactivos; sin embargo, estas librerías también cuentan con métodos que permiten utilizar shaders personalizados escritos directamente en lenguaje GLSL.</p>
        <img src="./imgs/shaders.png"><br>
        <code>Implementacion de Shaders personalizados en Three.js (izquierda) y P5.js (derecha)</code>
        <p>Estas funciones también permiten definir desde JavaScript las diferentes variables como Uniforms, Attributtes, Varyings y Textures a través de las cuales se pasa información a los shaders. Cada una de estas variables tiene diferentes usos que se definen como:</p>
        <p><b> - Attributes:</b> Son principalmente utilizados para pasar información al Vertex Shader sobre los objetos a renderizar, esta información es definida como "arreglos de vectores" también conocidos como Buffers, de esta manera podemos cargar por ejemplo una lista de posiciones de vértices de una figura en coordenadas [X,Y,Z].</p>
        <p><b> - Uniforms:</b> Son utilizadas para pasar variables a los shaders que serán iguales para cada vértice o pixel, estas variables pueden ser enteros, números de punto flotante, vectores o matrices.</p>
        <p><b> - Varyings:</b> Su principal función es pasar información del Vertex Shader al Fragment Shader, al definir un Varying con el mismo nombre en ambos shaders la información definida en un shader puede ser utilizada en el otro.</p>
        <p><b> - Textures:</b> Estas variables permiten pasar información de imágenes o "arreglos de píxeles" a los shaders.</p>
        <p>Los Shaders en su definición más simple definen el proceso de pasar la información de posición de cada vértice al vertex shader (con la variable gl_Position), y la información de color al fragment shader (con la variable gl_FragColor), ambos como un vector de dimensión 4.</p>
        <img src="./imgs/vertfrag.png"><br>
        <code>Vertex y Fragment Shaders mas simples</code>

    </section>
    <section>
        <hr>
        <h2>Dibujar un Triangulo - El "Hello World" de WebGL</h2> 
        <canvas id="canvas_01" width="800" height="600"></canvas><br>
        <h2>Multiples Triangulos</h2>
        <canvas id="canvas_02" width="800" height="600"></canvas><br>
        <h2>Triangulo con Color Buffer</h2>
        <canvas id="canvas_03" width="800" height="600"></canvas><br>
        <h2>Multiples Triangulos con Color Buffer</h2>
        <canvas id="canvas_04" width="800" height="600"></canvas><br>
        <h2>Figura a partir de Triangulos</h2>
        <canvas id="canvas_06" width="800" height="600"></canvas><br>
    </section>
    <section>
        <hr>
        <h2>Figura con Matrices de Transformacion (Mover, Rotar, Escalar)</h2>
        <canvas id="canvas_07" width="800" height="600"></canvas><br>
        <h2>3D Proyeccion Ortografica</h2>
        <canvas id="canvas_08" width="800" height="600"></canvas><br>
        <h2>3D Proyeccion Perspectiva con Matriz de Perspectiva</h2>
        <canvas id="canvas_09" width="800" height="600"></canvas><br>
        <h2>Movimiento de Camara con Matriz de Vista</h2>
        <canvas id="canvas_10" width="800" height="600"></canvas><br>
        <h2>WebGL Animado (Rotacion de Objeto animada)</h2>
        <canvas id="canvas_11" width="800" height="600"></canvas><br>
    </section>
    <section>
        <hr>
        <h2>Multiples Objetos</h2>
        <canvas id="canvas_12" width="800" height="600"></canvas><br>
        <h2>Multiples Tipos de Objetos Animados</h2>
        <canvas id="canvas_14" width="800" height="600"></canvas><br>
        <h2>Geometria con Texturas</h2>
        <canvas id="canvas_15" width="800" height="600"></canvas><br>
        <h2>Renderizacion a una Textura con FrameBuffer</h2>
        <canvas id="canvas_16" width="800" height="600"></canvas><br>
    </section>
    <section>
        <h2>Seleccion de Objetos con Mouse</h2>
        <canvas id="canvas_17" width="800" height="600"></canvas><br>
    </section>
    

    
    
    
    
    
    

    <script src="./my-utils.js"></script>
    <script src="./webgl-utils.js"></script>
    
    <script src="./01-triangle.js"></script>
    <script src="./02-randomTriangles.js"></script>
    <script src="./03-vertexTriangle.js"></script>
    <script src="./04-randomVertexTrianglesWithBuffers.js"></script>
    <script src="./05-RectangleWithTexture.js"></script>
    <script src="./06-MovRotScaleF.js"></script>
    <script src="./07-MovRotScaleMatrixF.js"></script>
    <script src="./08-3DIntroductionOrtho.js"></script>
    <script src="./09-3DPerspective.js"></script>
    <script src="./10-3DCameraView.js"></script>
    <script src="./11-3DAnimated.js"></script>
    <script src="./13-3D-MultipleObjs.js"></script>
    <script src="./14.75-3D-MultipleTypesObjsAnimMoreCode.js"></script>
    <script src="./15-3DTextureAnimated.js"></script>
    <script src="./17-3DRenderToTextureDepth.js"></script>
    <script src="./18-PICKING.js"></script>
</body>
</html>